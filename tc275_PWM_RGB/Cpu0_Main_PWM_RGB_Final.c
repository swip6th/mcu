/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "my_lib.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;


volatile unsigned int systick;
volatile unsigned int systick_curr;
volatile unsigned int systick_prev;
volatile unsigned int potential_meter;
volatile unsigned int potential_meter_duty;

volatile unsigned int red_duty;
volatile unsigned int green_duty;
volatile unsigned int blue_duty;

volatile unsigned int SW1_curr;
volatile unsigned int SW1_prev;
volatile unsigned int SW1_cnt;
volatile unsigned int SW1_debounce;

volatile unsigned int SW2_curr;
volatile unsigned int SW2_prev;
volatile unsigned int SW2_cnt;
volatile unsigned int SW2_debounce;

volatile unsigned int SW_state_curr;
volatile unsigned int SW_state_prev;
volatile unsigned int SW_state_cnt;
volatile unsigned int SW_state_debounce;

volatile unsigned char irq_timer;

int core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    init_LED();
    init_Switch();
    init_LED_RGB();
    init_GTM_TOM0_PWM_RGB();
    init_VADC();

    potential_meter_duty = 0;

    red_duty = 0;
    green_duty = 0;
    blue_duty = 0;

    SW1_curr = 0;
    SW1_prev = 0;
    SW1_cnt = 0;
    SW1_debounce = 0;
    SW2_curr = 0;
    SW2_prev = 0;
    SW2_cnt = 0;
    SW2_debounce = 0;
    SW_state_curr = 0;
    SW_state_prev = 0;
    SW_state_cnt = 0;
    SW_state_debounce = 0;

    irq_timer = 0;

    // CCU61 T12 100ms
    init_CCU6((myCCU6 *)&CCU61,100,0x0F);

    while(1)
    {
        // 100ms
        irq_timer = 0;
        while( irq_timer == 0 );

        SW_state_prev = SW_state_curr;
        SW_state_curr = (SW2_debounce<<1) | (SW1_debounce<<0);

        if( SW_state_curr != SW_state_prev )
            SW_state_cnt = 0;
        else if( SW_state_cnt < 10 )
            SW_state_cnt ++;
        else
            SW_state_debounce = SW_state_curr;

        if( SW_state_debounce != 0 )
        {
            potential_meter = GetVADC4(7);
            potential_meter_duty = (potential_meter*12500)/4095;

            if( potential_meter_duty == 0 )
                potential_meter_duty  = 0;
            else
                potential_meter_duty -= 1;


            // SW1 pushed     : blue     led on, RGB.blue  duty
            // SW2 pushed     : red      led on, RGB.red   duty
            // SW1&SW2 pushed : blue/red led on, RGB.green duty

            if     ( SW_state_debounce == 0x01 )                // SW1 is pushed, RGB.blue
            {
                PORT10_OMR = (1<<PCL1)  |                       // LED RED  off
                             (1<<PS2)   ;                       // LED BLUE on
                GTM_TOM0_CH3_SR0 = 12500 - 1;                   // PWM freq. = 6250 kHz / 12500 = 500 Hz
                GTM_TOM0_CH3_SR1 = potential_meter_duty;
            }
            else if( SW_state_debounce == 0x02 )                // SW2 is pushed, RGB.red
            {
                PORT10_OMR = (1<<PS1)   |                       // LED RED  on
                             (1<<PCL2)  ;                       // LED BLUE off
                GTM_TOM0_CH15_SR0 = 12500 - 1;                   // PWM freq. = 6250 kHz / 12500 = 500 Hz
                GTM_TOM0_CH15_SR1 = potential_meter_duty;
            }
            else                       // 0x03                  // SW1 & SW2 are pushed, RGB.green
            {
                PORT10_OMR = (1<<PS1)   |                       // LED RED  on
                             (1<<PS2)   ;                       // LED BLUE on
                GTM_TOM0_CH2_SR0 = 12500 - 1;                   // PWM freq. = 6250 kHz / 12500 = 500 Hz
                GTM_TOM0_CH2_SR1 = potential_meter_duty;
            }
        }
        else                                                    // SW1 & SW2 are open
        {
                PORT10_OMR = (1<<PCL1)  |                       // LED RED  off
                             (1<<PCL2)  ;                       // LED BLUE off
        }
    }
    return (1);
}


// 100ms timer
__interrupt( 0x0F ) __vector_table( 0 )
void CCU61_T12_ISR(void)
{
    SW1_prev = SW1_curr;
    SW1_curr = (PORT02_IN & (1<<P0)) == 0;
    SW2_prev = SW2_curr;
    SW2_curr = (PORT02_IN & (1<<P1)) == 0;

    if( SW1_curr != SW1_prev )
        SW1_cnt = 0;
    else if( SW1_cnt < 9 )
        SW1_cnt ++;
    else
        SW1_debounce = SW1_curr;

    if( SW2_curr != SW2_prev )
        SW2_cnt = 0;
    else if( SW1_cnt < 9 )
        SW2_cnt ++;
    else
        SW2_debounce = SW2_curr;

    irq_timer = 1;
}
